<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <title>trellis</title>
        <link rel="stylesheet" href="https://kvnchpl.github.io/main/main.css"/>
        <!-- <link rel="stylesheet" href="https://kvnchpl.github.io/trellis/trellis.css"> -->
        <style>
            :root {
                --body-bg: #f0f0f0;
                --font-family: Arial, sans-serif;

                --color-text-primary: #fff;
                --color-text-secondary: #000;
                --color-ui-bg: #333;
                --color-ui-bg-button: #555;
                --color-ui-bg-button-hover: #777;

                --color-container-bg: #ccc;
                --color-canvas-bg: #eee;
                --color-canvas-border: #999;

                --color-overlay-bg: rgba(0, 0, 0, 0.7);
                --color-overlay-text: #fff;
                --color-overlay-button-bg: #aaa;
                --color-overlay-button-text: #000;

                --game-width: 600px;
                --game-height: 600px;
                --sidebar-width: 300px;

                --spacing-unit: 0.5rem;
                --border-radius: 5px;
                --border-color: #ccc;
                --box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);

                --tile-default: #77dd77;
                --tile-empty: #e0e0e0;
                --tile-path: #bdbdbd;
                --tile-plot: #8b4513;
                --tile-player: #ffd700;
                --tile-highlight: red;
                --tile-tilled: #c2b280;
                --tile-moisture-high: #7ec850;
                --tile-moisture-low: #c2b280;
                --tile-plant-young: #7EC850;
                --tile-plant-mature: #98FB98;
            }

            .hidden {
                display: none !important;
            }

            body {
                margin: 0;
                font-family: var(--font-family);
                background: var(--body-bg);
            }

            #mainContent {
                display: flex;
                justify-content: center; /* Center the entire content horizontally */
                align-items: flex-start; /* Align the game container and sidebar at the top */
                margin: 0 auto; /* Center the entire layout within the viewport */
                gap: calc(var(--spacing-unit) * 4); /* Space between game container and sidebar */
                max-width: calc(var(--game-width) + var(--sidebar-width) + var(--spacing-unit) * 4); /* Constrain total width */
                padding: calc(var(--spacing-unit) * 4) 0; /* Add some vertical padding */
                box-sizing: border-box; /* Ensure padding is included in width calculations */
            }

            #gameContainer {
                position: relative;
                width: var(--game-width);
                height: var(--game-height);
                background: var(--color-container-bg);
                box-shadow: var(--box-shadow); /* Add shadow for visual distinction */
            }

            canvas {
                display: block;
                background: var(--color-canvas-bg);
                border: 2px solid var(--color-canvas-border);
            }

            #gameSidebar {
                display: flex;
                flex-direction: column;
                width: var(--sidebar-width); /* Defined in global variables */
                background: #f9f9f9;
                padding: calc(var(--spacing-unit) * 2);
                border: 1px solid var(--border-color);
                border-radius: var(--border-radius);
                box-shadow: var(--box-shadow);
                overflow: hidden; /* Prevent content overflow */
                box-sizing: border-box; /* Ensure padding doesn’t cause overflow */
            }

            #gameSidebar > div {
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                justify-content: flex-start;
                width: 100%;
                padding: calc(var(--spacing-unit) * 2);
                background: var(--color-ui-bg);
                color: var(--color-text-primary);
                border: 1px solid var(--border-color);
                border-radius: var(--border-radius);
                box-shadow: var(--box-shadow);
                font-size: 0.9rem;
                line-height: 1.4;
                box-sizing: border-box;
                margin-bottom: calc(var(--spacing-unit) * 2);
            }

            #gameSidebar > div strong {
                display: block;
                margin-bottom: var(--spacing-unit);
                font-size: 1rem;
            }

            #skipButtonContainer {
                display: flex;
                justify-content: space-between; /* Space out the buttons */
                align-items: center;
                margin-bottom: calc(var(--spacing-unit) * 2);
                padding: calc(var(--spacing-unit) * 2);
                background: var(--color-ui-bg);
                border: 1px solid var(--border-color);
                border-radius: var(--border-radius);
                box-shadow: var(--box-shadow);
                gap: calc(var(--spacing-unit) * 2); /* Add spacing between buttons */
            }

            #skipButtonContainer button {
                background: var(--color-ui-bg-button);
                color: var(--color-text-primary);
                padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 3);
                border: none;
                border-radius: var(--border-radius);
                cursor: pointer;
                font-size: 1rem;
                box-shadow: var(--box-shadow);
                transition: background 0.3s ease;
                flex: 1; /* Equal width for both buttons */
                max-width: 150px; /* Optional: Limit button width */
            }

            #skipButtonContainer button:hover {
                background: var(--color-ui-bg-button-hover);
            }

            #tileStats {
                background: #fff;
                font-size: 0.9rem;
            }

            /* Adjust existing #tileStatsContent styles */
            #tileStatsContent {
                display: flex;
                flex-direction: column;
                gap: var(--spacing-unit); /* Adds spacing between rows */
                width: 100%; /* Ensure it spans the container */
            }

            /* Ensure all children are styled consistently */
            #tileStatsContent div {
                display: flex;
                justify-content: space-between; /* Align labels and values */
                align-items: center;
                width: 100%; /* Ensure rows fill the available width */
                margin-bottom: var(--spacing-unit); /* Add spacing for clarity */
            }

            #actionHelp {
                position: relative; /* Enable precise placement of the heading */
                text-align: left; /* Align text consistently */
                font-size: 0.9rem;
            }

            #actionHelp em {
                position: absolute;
                top: calc(var(--spacing-unit) * 2); /* Align near the top of the section */
                left: calc(var(--spacing-unit) * 2); /* Align to the left */
                font-size: 1rem;
                font-weight: bold;
            }

            #tutorialOverlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%; /* Match the game container width */
                height: 100%; /* Match the game container height */
                background: var(--color-overlay-bg);
                color: var(--color-overlay-text);
                display: flex;
                flex-direction: column; /* Stack content vertically */
                justify-content: center; /* Center content vertically */
                align-items: center; /* Center content horizontally */
                text-align: center;
                padding: calc(var(--spacing-unit) * 4);
                z-index: 5;
                box-sizing: border-box; /* Include padding in size calculations */
                gap: calc(var(--spacing-unit) * 2); /* Space between paragraph and button */
            }

            #tutorialOverlay p {
                font-size: 1rem;
                line-height: 1.5;
                max-width: 80%; /* Constrain paragraph width for readability */
                margin: 0; /* Remove default margin */
            }

            #tutorialOverlay button {
                background: var(--color-overlay-button-bg);
                color: var(--color-overlay-button-text);
                padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 3);
                border: none;
                border-radius: var(--border-radius);
                cursor: pointer;
                font-size: 1rem;
                box-shadow: var(--box-shadow);
                transition: background 0.3s ease;
            }

            #tutorialOverlay button:hover {
                background: var(--color-overlay-bg);
                color: var(--color-overlay-text);
            }
        </style>
    </head>
    <body>
        <div id="mainContent">
            <div id="gameContainer">
                <canvas id="gameCanvas" width="600" height="600"></canvas>
                <div id="tutorialOverlay">
                    <p>
                        <strong>Welcome to Trellis!</strong><br /><br />
                        In this game, your goal is to grow a thriving and sustainable garden by carefully managing your time and resources. 
                        Use the <strong>arrow keys</strong> to move your character around the garden grid, and the <strong>WASD keys</strong> 
                        to highlight adjacent tiles for inspection or actions.<br /><br />
                        Each action—like tilling, planting, watering, or weeding—takes time, so plan your day wisely! 
                        The day starts at 7:00 AM and ends at 7:00 PM, after which you'll automatically move to the next week. 
                        You can also skip to the next week at any time.<br /><br />
                        Success depends on maintaining soil health, encouraging biodiversity, and growing a variety of plants 
                        without using harmful chemicals. Experiment, adapt, and enjoy the process of building a sustainable garden.<br /><br />
                        Good luck, and happy gardening!
                    </p>
                    <button id="closeTutorialBtn">Close Tutorial</button>
                </div>
            </div>
            <div id="gameSidebar">
                <!-- Skip and Reset Buttons -->
                <div id="skipButtonContainer">
                    <button id="nextWeekBtn">Next Week</button>
                    <button id="resetPositionBtn">Reset Position</button>
                </div>

                <!-- Game UI -->
                <div id="gameUI">
                    <div>
                        <strong>Time:</strong> <span id="timeDisplay">7:00 AM</span>
                    </div>
                    <div>
                        <strong>Year:</strong> <span id="yearDisplay">1</span>
                    </div>
                    <div>
                        <strong>Week:</strong> <span id="weekDisplay">1</span> (<span id="seasonDisplay">Winter</span>)
                    </div>
                    <div>
                        <strong>Biodiversity:</strong> <span id="biodiversityScore">0</span>
                    </div>
                </div>

                <!-- Tile Stats -->
                <div id="tileStats">
                    <strong>Tile Stats</strong>
                    <div id="tileStatsContent">
                    </div>
                </div>

                <!-- Action Help -->
                <div id="actionHelp">
                    <strong>Keyboard Shortcuts</strong><br />
                    1: Till<br />
                    2: Fertilize<br />
                    3: Plant<br />
                    4: Water<br />
                    5: Mulch<br />
                    6: Weed<br />
                    7: Harvest<br />
                    8: Clear<br />
                </div>
                <div id="inventory">

                </div>
            </div>
        </div>
        <!-- <script src="https://kvnchpl.github.io/trellis/trellis.js"></script> -->
        <script>

            /* GLOBALS */

            let gameData = null;

            let TILE_SIZE, GRID_WIDTH, GRID_HEIGHT;
            let DAY_START, DAY_END;
            let PEST_OUTBREAK_CHANCE;
            let BASE_MOISTURE_START, BASE_MOISTURE_DECAY;
            let REGION_NAME;

            let TILE_TYPE = {};
            let TIME_COST = {};
            let GROWTH_TIME = {};
            let PRODUCE_YIELD = {};

            const SEASONS = ["Winter", "Spring", "Summer", "Fall"];
            const WEEKS_PER_SEASON = 13;
            const WEEKS_PER_YEAR = WEEKS_PER_SEASON * SEASONS.length;

            /* GAME STATE */

            const gameState = {
                currentWeek: 1,
                currentYear: 1,
                currentSeason: "Winter",
                currentTime: 0, // Time in minutes past 7:00 AM
                biodiversityScore: 0,
                grid: [],
                player: {
                    x: null,
                    y: null,
                },
                highlightedTile: {
                    x: null,
                    y: null,
                },
                inventory: {
                    seeds: {
                        tomato: 5,
                        kale: 5,
                    },
                    produce: {
                        tomato: 0,
                        kale: 0,
                    },
                    fertilizer: 2,
                    mulch: 5,
                },
            };

            /* INITIALIZATION */

            window.onload = function() {
                fetch('https://kvnchpl.github.io/trellis/trellis.json')
                    .then(response => {
                    if (!response.ok) {
                        throw new Error("Failed to load trellis.json: " + response.status);
                    }
                    return response.json();
                })
                    .then(data => {
                    gameData = data;   // Store the JSON data
                    initGame();        // Initialize the game after data is set
                })
                    .catch(error => {
                    console.error("Error fetching trellis.json:", error);
                });
            };

            function initGame() {
                if (!gameData) {
                    console.error("Game data not loaded yet!");
                    return;
                }

                const { plants, timeCosts, gameConfig, tileTypes } = gameData;

                console.log("Initialized game with plant data:", plants);
                console.log("Action time costs:", timeCosts);
                console.log("Core game config:", gameConfig);
                console.log("Tile types:", tileTypes);

                // Configure game constants
                configureGameConstants(gameConfig, plants, timeCosts, tileTypes);


                // Set default placeholder for player position
                gameState.player.x = Math.floor(GRID_WIDTH / 2);
                gameState.player.y = Math.floor(GRID_HEIGHT / 2);

                // Initialize grid
                initGrid();

                // Reset player position (ensures synchronization with grid)
                resetPlayerPosition();

                // Initialize UI
                initializeUI();

                // Show the tutorial overlay
                showTutorial();

                // Attach event listeners
                attachEventListeners();
            }

            function initGrid() {
                gameState.grid = Array.from(
                    { length: GRID_HEIGHT },
                    () =>
                    Array.from({ length: GRID_WIDTH }, () => ({
                        type: TILE_TYPE.EMPTY,
                        isTilled: false,
                        plant: null,
                        weedLevel: 0,
                        moisture: BASE_MOISTURE_START,
                        moistureDecayRate: BASE_MOISTURE_DECAY,
                        soilNutrients: { N: 50, P: 50, K: 50 },
                    }))
                );

                console.log("Grid initialized:", gameState.grid);
            }

            function configureGameConstants(gameConfig, plants, timeCosts, tileTypes) {

                TILE_SIZE = gameConfig.TILE_SIZE;
                GRID_WIDTH = gameConfig.GRID_WIDTH;
                GRID_HEIGHT = gameConfig.GRID_HEIGHT;
                DAY_START = gameConfig.DAY_START;
                DAY_END = gameConfig.DAY_END;
                PEST_OUTBREAK_CHANCE = gameConfig.PEST_OUTBREAK_CHANCE;
                BASE_MOISTURE_START = gameConfig.BASE_MOISTURE_START;
                BASE_MOISTURE_DECAY = gameConfig.BASE_MOISTURE_DECAY;
                REGION_NAME = gameConfig.REGION_NAME;

                Object.assign(TILE_TYPE, tileTypes);
                Object.assign(TIME_COST, timeCosts);

                for (const [plant, data] of Object.entries(plants)) {
                    GROWTH_TIME[plant] = data.GROWTH_TIME;
                    PRODUCE_YIELD[plant] = data.PRODUCE_YIELD;
                }
            }

            function initializeUI() {
                generateTileStatsUI();
                updateYearAndSeason();
                updateWeekDisplay();
                updateBiodiversityDisplay();
            }

            function generateTileStatsUI() {
                const contentContainer = document.getElementById("tileStatsContent");
                contentContainer.innerHTML = ""; // Clear existing content

                // Use any tile as a reference for properties
                const exampleTile = initGrid()[0][0];

                Object.entries(exampleTile).forEach(([key, value]) => {
                    if (typeof value === "object") {
                        Object.keys(value).forEach((subKey) => {
                            appendTileStat(contentContainer, `${key} ${subKey}`);
                        });
                    } else {
                        appendTileStat(contentContainer, key);
                    }
                });
            }

            function appendTileStat(container, label) {
                const field = document.createElement("div");
                field.innerHTML = `
${capitalize(label)}:
<span id="tile${capitalize(label.replace(" ", ""))}">N/A</span>
`;
                container.appendChild(field);
            }

            // Helper function to capitalize strings
            function capitalize(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            }

            /* EVENT LISTENERS */

            function attachEventListeners() {

                // Skip to next week button
                document.getElementById("nextWeekBtn").addEventListener("click", skipToNextWeek);

                // Reset position button
                document.getElementById("resetPositionBtn").addEventListener("click", resetPlayerPosition);

                // Close tutorial button
                document.getElementById("closeTutorialBtn").addEventListener("click", hideTutorial);

                // Prevent scrolling with arrow keys
                window.addEventListener("keydown", preventArrowKeyScroll);

                // General keydown handler for gameplay
                window.addEventListener("keydown", handleKeyDown);
            }

            function preventArrowKeyScroll(e) {
                if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                    e.preventDefault();
                }
            }

            /* RENDERING */

            function render() {
                const canvas = document.getElementById("gameCanvas");
                const ctx = canvas.getContext("2d");

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the grid
                drawGrid(ctx);
            }

            function drawGrid(context) {
                for (let row = 0; row < GRID_HEIGHT; row++) {
                    for (let col = 0; col < GRID_WIDTH; col++) {
                        const tile = gameState.grid[row][col];

                        // Default tile color
                        let tileColor = getComputedStyle(document.documentElement).getPropertyValue("--tile-default").trim();

                        // Determine color based on type
                        if (tile.type === TILE_TYPE.PATH) {
                            tileColor = getComputedStyle(document.documentElement).getPropertyValue("--tile-path").trim();
                        } else if (tile.type === TILE_TYPE.PLOT) {
                            tileColor = getComputedStyle(document.documentElement).getPropertyValue("--tile-plot").trim();
                        }

                        // Modify color based on soil moisture
                        if (tile.moisture > 70) {
                            tileColor = getComputedStyle(document.documentElement).getPropertyValue("--tile-moisture-high").trim();
                        } else if (tile.moisture < 30) {
                            tileColor = getComputedStyle(document.documentElement).getPropertyValue("--tile-moisture-low").trim();
                        }

                        // Tilled tile color
                        if (tile.isTilled) {
                            tileColor = getComputedStyle(document.documentElement).getPropertyValue("--tile-tilled").trim();
                        }

                        // Plant growth stage colors
                        if (tile.plant) {
                            if (tile.plant.isMature) {
                                tileColor = getComputedStyle(document.documentElement).getPropertyValue("--tile-plant-mature").trim();
                            } else {
                                tileColor = getComputedStyle(document.documentElement).getPropertyValue("--tile-plant-young").trim();
                            }
                        }

                        context.fillStyle = tileColor;
                        context.fillRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                        // Highlight tile with a red border if it's the highlighted tile
                        if (row === gameState.highlightedTile.y && col === gameState.highlightedTile.x) {
                            context.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--tile-highlight").trim();
                            context.lineWidth = 3;
                            context.strokeRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        } else {
                            context.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--color-canvas-border").trim();
                            context.lineWidth = 1;
                            context.strokeRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }

                        // Add a bright border for the player position
                        if (row === gameState.player.y && col === gameState.player.x) {
                            context.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--tile-player").trim();
                            context.lineWidth = 3;
                            context.strokeRect(col * TILE_SIZE + 1, row * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                        }
                    }
                }
            }

            /* TIME & WEEK LOGIC */

            function advanceTime(minutes) {
                gameState.currentTime += minutes; // Update gameState.currentTime instead of currentTime

                if (gameState.currentTime >= DAY_END) {
                    skipToNextWeek();
                } else {
                    updateTimeDisplay();
                    render();
                }
            }

            function skipToNextWeek() {
                // Increment the week and reset time
                gameState.currentWeek++;
                gameState.currentTime = DAY_START;

                // Update time state (year and season)
                updateYearAndSeason();

                // Perform weekly updates for tiles
                updateAllTiles();
                updateBiodiversity();

                // Update UI
                updateTimeDisplay();
                updateWeekDisplay();
                updateBiodiversityDisplay();
                updateTileStats();

                // Re-render the grid
                render();
            }

            function updateYearAndSeason() {
                gameState.currentYear = Math.floor(gameState.currentWeek / WEEKS_PER_YEAR) + 1;
                gameState.currentSeason = SEASONS[Math.floor((gameState.currentWeek % WEEKS_PER_YEAR) / WEEKS_PER_SEASON)];

                // Update the display
                document.getElementById("yearDisplay").textContent = gameState.currentYear;
                document.getElementById("seasonDisplay").textContent = gameState.currentSeason;
            }

            function updateBiodiversity() {
                const typesFound = new Set();

                for (let row = 0; row < GRID_HEIGHT; row++) {
                    for (let col = 0; col < GRID_WIDTH; col++) {
                        const tile = gameState.grid[row][col];
                        if (tile.plant) {
                            typesFound.add(tile.plant.type);
                        }
                    }
                }

                gameState.biodiversityScore = typesFound.size;
                return gameState.biodiversityScore;
            }

            /* PLAYER MOVEMENT & CONTROLS */

            function handleKeyDown(e) {
                let newX = gameState.player.x;
                let newY = gameState.player.y;

                switch (e.key) {
                        // Player movement (Arrow keys)
                    case "ArrowUp":
                        newY = gameState.player.y - 1;
                        break;
                    case "ArrowDown":
                        newY = gameState.player.y + 1;
                        break;
                    case "ArrowLeft":
                        newX = gameState.player.x - 1;
                        break;
                    case "ArrowRight":
                        newX = gameState.player.x + 1;
                        break;

                        // Highlight adjacent tiles (WASD keys)
                    case "w":
                    case "W":
                        highlightTile(gameState.player.x, gameState.player.y - 1); // Highlight above
                        return;
                    case "s":
                    case "S":
                        highlightTile(gameState.player.x, gameState.player.y + 1); // Highlight below
                        return;
                    case "a":
                    case "A":
                        highlightTile(gameState.player.x - 1, gameState.player.y); // Highlight left
                        return;
                    case "d":
                    case "D":
                        highlightTile(gameState.player.x + 1, gameState.player.y); // Highlight right
                        return;
                    case "q":
                    case "Q":
                        highlightTile(gameState.player.x, gameState.player.y); // Highlight player tile
                        return;

                        // Actions (Keys 1–8)
                    case "1": // Till
                        tillSoil();
                        break;
                    case "2": // Fertilize
                        fertilizeTile();
                        break;
                    case "3": // Plant
                        plantSeed("tomato"); // Example default plant type
                        break;
                    case "4": // Water
                        waterTile();
                        break;
                    case "5": // Mulch
                        mulchTile();
                        break;
                    case "6": // Weed
                        weedTile();
                        break;
                    case "7": // Harvest
                        harvestPlant();
                        break;
                    case "8": // Clear
                        clearPlot();
                        break;

                    default:
                        return; // Do nothing for other keys
                }

                // Check if the player is attempting to move to a new tile
                if (newX !== gameState.player.x || newY !== gameState.player.y) {
                    // Prevent movement if the target tile is out of bounds or a plot
                    if (
                        newX >= 0 &&
                        newX < GRID_WIDTH &&
                        newY >= 0 &&
                        newY < GRID_HEIGHT &&
                        gameState.grid[newY][newX].type !== TILE_TYPE.PLOT
                    ) {
                        gameState.player.x = newX;
                        gameState.player.y = newY;

                        // Reset highlighted tile to the player's current position
                        highlightTile(gameState.player.x, gameState.player.y);

                        render();
                    } else {
                        console.log("Cannot move onto this tile!");
                    }
                }
            }

            function resetPlayerPosition() {
                if (!gameState.grid || gameState.grid.length === 0) {
                    console.error("Cannot reset player position: grid not initialized.");
                    return;
                }

                // Reset player position to the center of the grid
                gameState.player.x = Math.floor(GRID_WIDTH / 2);
                gameState.player.y = Math.floor(GRID_HEIGHT / 2);

                // Align the highlighted tile with the player's position
                gameState.highlightedTile = { x: gameState.player.x, y: gameState.player.y };

                highlightTile(gameState.player.x, gameState.player.y);
                updateTileStats();
                render();
            }

            document.getElementById("gameCanvas").addEventListener("click", (e) => {
                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();

                const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
                const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);

                highlightTile(x, y); // Directly call highlightTile with the clicked coordinates
            });
            function highlightTile(x, y) {
                if (isTileValid(x, y) && (isTileAdjacent(x, y) || isPlayerOnTile(x, y))) {
                    gameState.highlightedTile = { x, y };
                    updateTileStats();
                    render();
                } else {
                    console.log("Invalid tile for highlighting.");
                }
            }

            /* TILE & GRID UPDATES */

            function updateAllTiles() {
                for (let row = 0; row < GRID_HEIGHT; row++) {
                    for (let col = 0; col < GRID_WIDTH; col++) {
                        const tile = gameState.grid[row][col];
                        updateTileMoisture(tile);
                        updateTilePlant(tile, row, col);
                    }
                }
            }

            function updateTileMoisture(tile) {
                tile.moisture = Math.max(tile.moisture - tile.moistureDecayRate, 0);
            }

            function updateTilePlant(tile, row, col) {
                if (!tile.plant) return;

                const plantType = tile.plant.type;
                const plantData = gameData.plants[plantType];

                // Extract soil properties
                const { N, P, K } = tile.soilNutrients;
                const sufficientNutrients = N >= 30 && P >= 20 && K >= 20;
                const sufficientMoisture = tile.moisture >= 40;

                // Grow plant if conditions are sufficient
                if (sufficientNutrients && sufficientMoisture) {
                    tile.plant.age += 1;
                } else {
                    console.log(`Plant at (${row}, ${col}) is growing slowly due to poor conditions.`);
                }

                // Deplete nutrients if the plant is growing
                if (sufficientNutrients) {
                    tile.soilNutrients.N = Math.max(N - 10, 0);
                    tile.soilNutrients.P = Math.max(P - 5, 0);
                    tile.soilNutrients.K = Math.max(K - 5, 0);
                }

                // Check if the plant is mature
                if (tile.plant.age >= plantData.growthTime) {
                    tile.plant.isMature = true;
                }
            }

            function updateTileStats() {
                const { x, y } = gameState.highlightedTile;
                const tile = gameState.grid[y][x];

                for (const key in tile) {
                    if (typeof tile[key] === "object") {
                        for (const subKey in tile[key]) {
                            const element = document.getElementById(`tile${capitalize(key)}${capitalize(subKey)}`);
                            if (element) {
                                element.textContent = tile[key][subKey];
                            }
                        }
                    } else {
                        const element = document.getElementById(`tile${capitalize(key)}`);
                        if (element) {
                            element.textContent = tile[key] !== null ? tile[key] : "N/A";
                        }
                    }
                }
            }

            function clearTileStats() {
                const statsContainer = document.getElementById("tileStats");
                const spans = statsContainer.querySelectorAll("span");
                spans.forEach(span => (span.textContent = "N/A"));
            }

            /* UI UPDATES */

            function updateTimeDisplay() {
                const timeDisplay = document.getElementById("timeDisplay");

                // Convert gameState.currentTime (minutes since 7:00 AM) to HH:MM format
                let totalMinutes = gameState.currentTime;
                let hours = 7 + Math.floor(totalMinutes / 60);
                let minutes = totalMinutes % 60;
                let ampm = hours >= 12 ? "PM" : "AM";

                // Convert to 12-hour format
                if (hours > 12) hours -= 12;
                if (hours === 0) hours = 12;

                const formattedMinutes = minutes < 10 ? "0" + minutes : minutes;
                timeDisplay.textContent = `${hours}:${formattedMinutes} ${ampm}`;
            }

            function updateWeekDisplay() {
                document.getElementById("weekDisplay").textContent = gameState.currentWeek;
            }

            function updateBiodiversityDisplay() {
                document.getElementById("biodiversityScore").textContent = gameState.biodiversityScore;
            }

            /* PLAYER ACTIONS */

            // TILL
            function tillSoil() {
                const tile = getTargetTile();

                if (tile.type === TILE_TYPE.EMPTY) {
                    tile.type = TILE_TYPE.PLOT;
                    tile.isTilled = true;

                    console.log("Soil tilled at:", tile);
                    advanceTime(TIME_COST.TILL);
                    updateTileStats();
                } else {
                    console.log("Cannot till this tile.");
                }
            }

            // FERTILIZE
            function fertilizeTile() {
                const tile = getTargetTile();

                if (gameState.inventory.fertilizer > 0) {
                    tile.soilNutrients.N = Math.min(tile.soilNutrients.N + 20, 100);
                    tile.soilNutrients.P = Math.min(tile.soilNutrients.P + 10, 100);
                    tile.soilNutrients.K = Math.min(tile.soilNutrients.K + 10, 100);
                    gameState.inventory.fertilizer--;

                    console.log("Fertilized tile at:", tile);
                    advanceTime(TIME_COST.FERTILIZE);
                    updateTileStats();
                } else {
                    console.log("No fertilizer left!");
                }
            }

            // PLANT
            function plantSeed(seedType) {
                const tile = getTargetTile();
                if (!tile.isTilled) {
                    console.log("Soil is not tilled. Cannot plant yet.");
                    return;
                }
                if (tile.plant !== null) {
                    console.log("There's already a plant here!");
                    return;
                }
                if (gameState.inventory.seeds[seedType] && gameState.inventory.seeds[seedType] > 0) {
                    // Use 1 seed
                    gameState.inventory.seeds[seedType]--;
                    // Create a new plant object
                    tile.plant = {
                        type: seedType,
                        age: 0,
                        isMature: false
                    };
                    console.log(`Planted ${seedType} at (${player.x}, ${player.y})`);
                    advanceTime(TIME_COST.PLANT);
                    updateTileStats();
                } else {
                    console.log(`No ${seedType} seeds left.`);
                }
            }

            // WATER
            function waterTile() {
                const tile = getTargetTile();

                tile.moisture = Math.min(tile.moisture + 20, 100);

                console.log("Watered tile at:", tile);
                advanceTime(TIME_COST.WATER);
                updateTileStats();
            }

            // MULCH
            function mulchTile() {
                const tile = getTargetTile();

                if (gameState.inventory.mulch > 0) {
                    tile.moistureDecayRate = Math.max(tile.moistureDecayRate - 1, 0);
                    gameState.inventory.mulch--;

                    console.log("Mulched tile at:", tile);
                    advanceTime(TIME_COST.MULCH);
                    updateTileStats();
                } else {
                    console.log("No mulch left!");
                }
            }

            // WEED
            function weedTile() {
                const tile = getTargetTile();

                if (tile.weedLevel > 0) {
                    tile.weedLevel = 0;

                    console.log("Weeds removed at:", tile);
                    advanceTime(TIME_COST.WEED);
                    updateTileStats();
                } else {
                    console.log("No weeds here.");
                }
            }

            // HARVEST
            function harvestPlant() {
                const tile = getTargetTile();

                if (tile.plant && tile.plant.isMature) {
                    const type = tile.plant.type;
                    gameState.inventory.produce[type] = (gameState.inventory.produce[type] || 0) + PRODUCE_YIELD[type];

                    console.log(`Harvested ${type} at:`, tile);

                    tile.plant = null; // Remove the plant after harvesting
                    tile.isTilled = false; // Optionally revert to untilled
                    advanceTime(TIME_COST.HARVEST);
                    updateTileStats();
                } else {
                    console.log("No mature plant to harvest here.");
                }
            }

            // CLEAR
            function clearPlot() {
                const tile = getTargetTile();

                if (tile.type === TILE_TYPE.PLOT) {
                    tile.type = TILE_TYPE.EMPTY;
                    tile.isTilled = false;
                    tile.plant = null;

                    console.log("Plot cleared at:", tile);
                    advanceTime(TIME_COST.CLEAR);
                    updateTileStats();
                } else {
                    console.log("This tile is not a plot.");
                }
            }

            /* INVENTORY */

            function updateInventoryDisplay() {
                Object.entries(gameState.inventory).forEach(([category, items]) => {
                    Object.entries(items).forEach(([item, quantity]) => {
                        const element = document.getElementById(`inventory${capitalize(item)}`);
                        if (element) {
                            element.textContent = quantity;
                        }
                    });
                });
            }

            /* TUTORIAL OVERLAY */

            function showTutorial() {
                document.getElementById("tutorialOverlay").classList.remove("hidden");
            }

            function hideTutorial() {
                document.getElementById("tutorialOverlay").classList.add("hidden");
            }

            /* UTILITY FUNCTIONS */

            function getTargetTile() {
                const { x, y } = gameState.highlightedTile.x !== null ? gameState.highlightedTile : gameState.player;
                return gameState.grid[y][x];
            }

            function isTileValid(x, y) {
                return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
            }

            function isTileAdjacent(x, y) {
                return Math.abs(gameState.player.x - x) + Math.abs(gameState.player.y - y) <= 1;
            }

        </script>
    </body>
</html>